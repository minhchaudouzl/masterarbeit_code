---
title: "Generierung und Simulation der multivariat normalverteilten Parametervektoren"
author: "Minh Chau Do"
date: "2023-11-03"
output: pdf_document
---

```{r setup, include=FALSE, results='hide'}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

# Laden der erforderlichen Pakete
library(survival)
library(stats)
library(survRM2)
library(YPmodel)
library(riskRegression)
library(rlist)
```

Die Funktion generate_mixture_data() generiert einen einzelnen Datensatz mit einer Mischung von Weibull- und Exponentialverteilung. Der Beispielaufruf gleason_data erzeugt 10 solcher Datensätze für die Gleason-Studie mithilfe der Parameter, die vorher bereits an eine Mischverteilung von Weibull- und Exponentialverteilung angepasst wurden.

```{r generate, echo=TRUE, warning=FALSE, error=FALSE}
# Funktion zur Generierung eines einzelnen Datensatzes mit Mischung von Weibull und Exponentialverteilung
set.seed(2023)

generate_mixture_data <- function(n_c, n_e = n_c, parameter, cens_rate, tau) {
  ok <- FALSE
  while(!ok) {
    t_c <- c(rweibull(n = round(parameter["mix1"] * n_c, 0),
                             shape = parameter["shape1"],
                             scale = parameter["scale1"]),
             rexp(n = n_c - round(parameter["mix1"] * n_c, 0),
                         rate = parameter["rate1"]))
    t_e <- c(rweibull(n = round(parameter["mix2"] * n_e, 0),
                             shape = parameter["shape2"], 
                             scale = parameter["scale2"]),
             rexp(n = n_e - round(parameter["mix2"] * n_e, 0),
                         rate = parameter["rate2"]))
    Zeiten <- c(t_c, t_e)
    censZeit <- rexp(n = n_e + n_c, rate = -log(1 - cens_rate))
    Zeitec <- pmin(Zeiten, censZeit)
    Events <- as.integer(Zeiten <= censZeit)
    
    Zeit <- Zeitec
    Zeit_c <- Zeit[1:n_c][Events[1:n_c] == 1]
    tau_hat_c <- min(Zeit_c[Zeit_c > tau])
    Zeit_e <- Zeit[(n_e + 1):(n_c + n_e)][Events[(n_c + 1):(n_c + n_e)] == 1]
    tau_hat_e <- min(Zeit_e[Zeit_e > tau])
    tau_hat <- min(tau_hat_c, tau_hat_e)
    ok <- !(is.na(tau_hat) | is.infinite(tau_hat))
  }
  
  tau_hut <- c(rep(tau_hat_c, n_c), rep(tau_hat_e, n_e))
  Events[Zeit > tau_hut] <- 0 
  Zeit[Zeit > tau_hut] <- tau_hut[Zeit > tau_hut]
  
  a <- data.frame(Zeit = Zeit, Zensierung = Events, arm = c(rep(0, n_c), rep(1, n_e)))
  
  return(a)
}
```

```{r gleason, echo=TRUE, warning=FALSE, error=FALSE}
# Startparameter
gleason_parameter <- c(mix1 = 0.895, shape1 = 1.21, scale1 = 82.9, rate1 = 0.523,
                       mix2 = 0.907, shape2 = 1.58, scale2 = 76.4, rate2 = 0.283)

gleason_tau <- 60


gleason_data <- replicate(10, 
                        generate_mixture_data(n_c = 100, n_e = 100, gleason_parameter, 
                                              cens_rate = 0.05, gleason_tau), 
                        simplify = FALSE)
```


```{r jorgensen, echo=TRUE, warning=FALSE, error=FALSE}
# Startparameter
jorgensen_parameter <- c(mix1 = 0.93, shape1 = 1.69, scale1 = 116, rate1 = 1.35,
                         mix2 = 0.95, shape2 = 1.56, scale2 = 112, rate2 = 3.78)

jorgensen_tau <- 96

jorgensen_data <- replicate(10,
                        generate_mixture_data(n_c = 100, n_e = 100, jorgensen_parameter,
                                              cens_rate = 0.05, jorgensen_tau),
                        simplify = FALSE)
```

```{r leon, echo=TRUE, warning=FALSE, error=FALSE}
# Startparameter
leon_parameter <- c(mix1 = 0.508, shape1 = 0.348, scale1 = 198, rate1 = 0.001,
                    mix2 = 0.5, shape2 = 0.291, scale2 = 2500, rate2 = 0.00733)

leon_tau <- 24

leon_data <- replicate(10, 
                        generate_mixture_data(n_c = 100, n_e = 100, leon_parameter, 
                                              cens_rate = 0.05, leon_tau), 
                        simplify = FALSE)
```

```{r mack, echo=TRUE, warning=FALSE, error=FALSE}
# Startparameter
mack_parameter <- c(mix1 = 0.87, shape1 = 1.29, scale1 = 259, rate1 = 1.28,
                    mix2 = 0.93, shape2 = 1.54, scale2 = 178, rate2 = 1.03)

mack_tau <- 60

mack_data <- replicate(10, 
                        generate_mixture_data(n_c = 100, n_e = 100, mack_parameter, 
                                              cens_rate = 0.05, mack_tau), 
                        simplify = FALSE)
```

```{r makkar2012, echo=TRUE, warning=FALSE, error=FALSE}
# Startparameter
makkar2012_parameter <- c(mix1 = 0.5, shape1 = 1.1, scale1 = 7.56, rate1 = 0.02,
                          mix2 = 0.892, shape2 = 0.539, scale2 = 92.2, rate2 = 0.374)

makkar2012_tau <- 24

makkar2012_data <- replicate(10, 
                        generate_mixture_data(n_c = 100, n_e = 100, makkar2012_parameter, 
                                              cens_rate = 0.05, makkar2012_tau), 
                        simplify = FALSE)
```

```{r makkar2020, echo=TRUE, warning=FALSE, error=FALSE}
# Startparameter
makkar2020_parameter <- c(mix1 = 0.87, shape1 = 1.46, scale1 = 109, rate1 = 1.74,
                          mix2 = 0.884, shape2 = 1.76, scale2 = 86.1, rate2 = 0.59)

makkar2020_tau <- 60

makkar2020_data <- replicate(10, 
                        generate_mixture_data(n_c = 100, n_e = 100, makkar2020_parameter, 
                                              cens_rate = 0.05, makkar2020_tau), 
                        simplify = FALSE)
```

```{r popma, echo=TRUE, warning=FALSE, error=FALSE}
# Startparameter
popma_parameter <- c(mix1 = 0.97, shape1 = 2.02, scale1 = 109, rate1 = 2.39,
                    mix2 = 0.976, shape2 = 3.44, scale2 = 60.1, rate2 = 0.253)

popma_tau <- 24

popma_data <- replicate(10, 
                        generate_mixture_data(n_c = 100, n_e = 100, popma_parameter, 
                                              cens_rate = 0.05, popma_tau), 
                        simplify = FALSE)
```

```{r thyregod, echo=TRUE, warning=FALSE, error=FALSE}
# Startparameter
thyregod_parameter <- c(mix1 = 0.852, shape1 = 1.94, scale1 = 112, rate1 = 0.471,
                        mix2 = 0.905, shape2 = 1.64, scale2 = 109, rate2 = 0.732)

thyregod_tau <- 60

thyregod_data <- replicate(10, 
                        generate_mixture_data(n_c = 100, n_e = 100, thyregod_parameter, 
                                              cens_rate = 0.05, thyregod_tau), 
                        simplify = FALSE)
```

Die Funktion fitting() schätzt die besten Parameter, um die generierten Datensätze (je Behandlungsarm) auch wieder einer Mischverteilung aus Weibull- und Exponentialverteilung anzupassen. Der Beispielaufruf fit_gleason verwendet die generierten Daten und gibt die geschätzten Parameter sowie den Fehler für jeden Behandlungsarm aus.

```{r fitting, echo=TRUE, warning=FALSE, error=FALSE}
# Mischung aus Weibull- und Exponentialverteilung
# Das ist mein Pfad, diesen muessen Sie durch Ihren Pfad zur Simulation.zip ersetzen
mypath <- "D:/MA_Do_RProgramme"

source(paste(mypath, "/Simulation/R Funktionen/getweibex.R", sep = ""))

fitting <- function(sim_df) {
  
  results <- lapply(1:length(sim_df), function(i) {
    data <- sim_df[[i]]
    
    # Hier trennen wir die Daten nach dem Behandlungsarm (data$arm)
    unique_arms <- unique(data$arm)
    
    arm_results <- lapply(unique_arms, function(arm) {
      arm_data <- data[data$arm == arm, ]  
      
      best_errors <- numeric()  # Vektor für Fehlerwerte
      best_starts <- matrix(nrow = 0, ncol = 4)  # Matrix für Startparameter
      best_params <- matrix(nrow = 0, ncol = 4)  # Matrix für Parameter der Verteilung
      
      # Zwei Startwerte pro Parameter
      start_combinations <- expand.grid(
        shape = c(0.2, 0.8, 1.2),
        scale = c(0.2, 100, 200),
        rate = c(80, 120),
        mix = c(0.3, 0.6, 0.9, 0.95)
      )
      
      for (j in 1:nrow(start_combinations)) {
        start_params <- unname(unlist(start_combinations[j, ]))
        
        km <- survfit(Surv(Zeit, Zensierung)~1, data=arm_data)
        
        km_data <- data.frame(t = km$time,
                              surv = km$surv)
        
        km_data <- km_data[complete.cases(km_data),]
        
        km_data <- km_data[order(km_data$surv), ]
        
        #Datensortierung
        pq_data <- data.frame(x = km_data$t,
                              y = 1-km_data$surv)
  
        pq_data <- pq_data[complete.cases(pq_data),]
        
        pq_data <- pq_data[order(pq_data$y), ]
        
        q <- sort(pq_data$x)
        p <- pq_data$y
        
        
        # Schätze die Weibull-Parameter mit den aktuellen Startparametern
        output <- capture.output({
          result <- getweibex(p = p, q = q,
                              start = start_params,
                              show.output = TRUE, plot = FALSE)
        })
        
        # Berechne den Fehler (gleason_r_1$value) für die aktuellen Startparameter
        current_error <- as.numeric(gsub("\\[1\\]\\s+", "", output[5]))
        # Gebe Parameter für angepasste Verteilung aus
        current_params <- gsub("^\\[1\\]\\s+", "", output[2])
        params_vector <- as.numeric(strsplit(current_params, "\\s+")[[1]])
        
        # Speichere Fehler, Startparameter und Parameter, wenn der Fehler nicht NA ist
        if (!is.na(current_error)) {
          best_errors <- c(best_errors, current_error)
          best_starts <- rbind(best_starts, start_params)
          best_params <- rbind(best_params, params_vector)
        }
      }
      
      # Finde den Index des kleinsten Fehlers (ignoriere NA-Werte)
      best_index <- which.min(best_errors)
      # Kleinster Fehler
      best_error <- best_errors[best_index]
      
      # Wähle den Parameter mit dem kleinsten Fehler aus
      best_par <- best_params[best_index, ]
      # Parameter auf geeigneten Skalenraum transformieren
      # c("shape", "scale", "rate", "mix")
      best_par_trans <- c(log(best_par[1]), log(best_par[2]), log(best_par[3]),
                          best_par[4])
      # mix Parameter rücktransformieren
      best_par[4] <- exp(best_par[4]) / ( 1 + exp(best_par[4]))
      
      return(list(arm = arm, best_par = best_par, best_par_trans = best_par_trans, 
                  best_error = best_error))
    })
    
    return(arm_results)
  })
  
  return(results)
}


fit_gleason <- fitting(gleason_data)

fit_jorgensen <- fitting(jorgensen_data)

fit_leon <- fitting(leon_data)

fit_mack <- fitting(mack_data)

fit_makkar2012 <- fitting(makkar2012_data)

fit_makkar2020 <- fitting(makkar2020_data)

fit_popma <- fitting(popma_data)

fit_thyregod <- fitting(thyregod_data)

all_fit_results <- c(fit_gleason, fit_jorgensen, fit_leon, fit_mack, 
                     fit_makkar2012, fit_makkar2020, fit_popma, fit_thyregod)
```



Die geschätzten, transformierten Parameter aus der fitting Funktion werden für jeden Behandlungsarm werden, und Mittelwerte sowie Kovarianzmatrizen werden berechnet. Anschließend werden Zufallsdaten aus der multivariaten Normalverteilung mithilfe der mvrnorm()-Funktion generiert. Ausgegeben werden am Ende die Mittelwerte bzw. Kovarianzmatrizen je Behandlungsarm, die transformierten Parametervektoren und die rücktransformierten Parametervektoren, die aus der Normalverteilung generiert wurden.


```{r mvnorm_function, echo=TRUE, error=FALSE, warning=FALSE}
library(MASS)
library(MVN)
library(BBmisc)

# Funktion zur Datenextraktion und Simulation
simulate_data_mv <- function(fit_results, n_simulations = 100) {
  # Extrahiere die geschätzten Parameter für jeden Datensatz
  params_list_0 <- lapply(fit_results, function(result) result[[1]]$best_par_trans)
  params_list_1 <- lapply(fit_results, function(result) result[[2]]$best_par_trans)
  
  # Mittelwerte und Kovarianzmatrizen für jeden Behandlungsarm
  mean_params_list_0 <- colMeans(do.call(rbind, params_list_0), na.rm = TRUE)
  cov_matrix_list_0 <- cov(do.call(rbind, params_list_0))
  
  mean_params_list_1 <- colMeans(do.call(rbind, params_list_1), na.rm = TRUE)
  cov_matrix_list_1 <- cov(do.call(rbind, params_list_1))
  
  Sigma_0 <- 1/10 * cov_matrix_list_0
  Sigma_1 <- 1/10 * cov_matrix_list_1 
  
  # Erstellen von Zufallsdaten aus der multivariaten Normalverteilung
  mv_data_0 <- mvrnorm(n = n_simulations, mu = mean_params_list_0, 
                       Sigma = Sigma_0)
  mv_data_1 <- mvrnorm(n = n_simulations, mu = mean_params_list_1, 
                       Sigma = Sigma_1)
  
  mv_data <- as.data.frame(rbind(mv_data_0, 
                                 mv_data_1))
  
  mv_data <- cbind(mv_data, c(rep(0, n_simulations), rep(1, n_simulations)))
  colnames(mv_data) <- c("shape", "scale", "rate", "mix", "arm")
  
  # Transformieren der simulierten Daten in den Ursprungsskalenraum
  mv_data_transformed <- t(apply(mv_data, 1, function(row) {
    c(exp(row[1:3]), exp(row[4]) / ( 1 + exp(row[4])), row[5])
  }))
  
  # Rückgabe als Liste
  result_list <- list(
    mu_0 = mean_params_list_0,
    Sigma_0 = Sigma_0,
    mu_1 = mean_params_list_1,
    Sigma_1 = Sigma_1,
    mv_data = mv_data,
    mv_data_transformed = mv_data_transformed
  )
  
  return(result_list)
}

mvn_list_gleason <- simulate_data_mv(fit_gleason)
mvn_list_jorgensen <- simulate_data_mv(fit_jorgensen)
mvn_list_leon <- simulate_data_mv(fit_leon)
mvn_list_mack <- simulate_data_mv(fit_mack)
mvn_list_makkar2012 <- simulate_data_mv(fit_makkar2012)
mvn_list_makkar2020 <- simulate_data_mv(fit_makkar2020)
mvn_list_popma <- simulate_data_mv(fit_popma)
mvn_list_thyregod <- simulate_data_mv(fit_thyregod)
mvn_list_all <- simulate_data_mv(all_fit_results, 200)
list.save(mvn_list_all, paste0(mypath, "/Simulation/all/mvn_list_all.rds"))
```

Die Funktion calculate_squared_deviation() berechnet die quadratische Abweichung zwischen der  kumulative Inzidenzfunktion (CIF) aus den geschätzten Parametervektoren der Normalverteilung  (gemischte Weibull- und exponentielle Verteilung) und der rekonstruierten (z.B. aus der Gleason-Studie) Überlebenskurve mittels des Guyot Algorithmus. Der Beispielaufruf gleason_squared_deviation berechnet die quadratische Abweichung für jeden simulierten Datensatz der Gleason-Studie bei allen beobachteten Zeitpunkten und gibt zudem die gesamte summierte quadratische Abweichung aus.

```{r abweichung, echo=TRUE, warning=FALSE, error=FALSE}
calculate_squared_deviation <- function(guyot_data, estimated_nv) {
  # estimated_nv: Liste mit geschätzten Daten aus der Normalverteilung
    
  # Fall, dass wir die quadratische Abweichung für Standardbehandlung berechnen
  if(estimated_nv[5] == 0){
    gr_0 <- guyot_data[guyot_data$group == 0, ]
    fit_0 <- survfit(Surv(time, status) ~ group, data = gr_0)
    reconstruction <- data.frame(time = fit_0$time,
                                 surv = 1 - fit_0$surv)
  } 
  # Fall, dass wir die quadratische Abweichung für Experimentalbehandlung berechnen
  else if(estimated_nv[5] == 1){
    gr_1 <- guyot_data[guyot_data$group == 1, ]
    fit_1 <- survfit(Surv(time, status) ~ group, data = gr_1)
    reconstruction <- data.frame(time = fit_1$time,
                                 surv = 1 - fit_1$surv)
  }
  
  mix <- estimated_nv[4]
  shape <- estimated_nv[1]
  scale <- estimated_nv[2]
  rate <- estimated_nv[3]
  
  time_points <- reconstruction[, 1]
  
  estimated_cif <- (mix) * pweibull(q = time_points, shape = shape, scale = scale) +
                   (1 - mix) * pexp(q = time_points, rate = rate)
  
  observed_cif <- reconstruction[, 2]

  # Berechne die quadrierte Abweichung für jeden Datenpunkt
  squared_deviation <- (estimated_cif - observed_cif)^2
  
  # Summiere die quadrierten Abweichungen auf
  sum_squared_deviation <- sum(squared_deviation)
  
  return(list(squared_deviation = squared_deviation, sum_squared_deviation = sum_squared_deviation))
}

prepare_data <- function(data_dir_blau, data_dir_rot) {
  data_b <- read.csv2(paste0(mypath, data_dir_blau), sep = ";", header = FALSE)
  data_r <- read.csv2(paste0(mypath, data_dir_rot), sep = ";", header = FALSE)

  data <- rbind(data_b, data_r)
  colnames(data) <- c("time", "status", "group")
  
  data$time <- as.numeric(data$time)
  data$status <- as.numeric(data$status)
  data$group <- as.numeric(data$group)
  
  # Überlebenskurven ohne senkrechte Linien am Ursprung
  data <- rbind(c(0, 0, 1), data)
  data <- rbind(c(0, 0, 0), data)
  
  return(data)
}

gleason <- prepare_data("/Rekonstruktion/Gleason/gleason_blau_guyot.csv", "/Rekonstruktion/Gleason/gleason_rot_guyot.csv")

# Beispielaufruf für den Gleason
gleason_squared_deviation <- apply(mvn_list_gleason[[6]], 1,
                                   function(param_vec) {
  calculate_squared_deviation(gleason, param_vec)
})


jorgensen <- prepare_data("/Rekonstruktion/Jorgensen/jorgensen_blau_guyot.csv", "/Rekonstruktion/Jorgensen/jorgensen_rot_guyot.csv")

jorgensen_squared_deviation <- apply(mvn_list_jorgensen[[6]], 1, function(param_vec) {
  calculate_squared_deviation(jorgensen, param_vec)
})


leon <- prepare_data("/Rekonstruktion/Leon/leon_blau_guyot.csv", "/Rekonstruktion/Leon/leon_rot_guyot.csv")

leon_squared_deviation <- apply(mvn_list_leon[[6]], 1, function(param_vec) {
  calculate_squared_deviation(leon, param_vec)
})


mack <- prepare_data("/Rekonstruktion/Mack/mack_blau_guyot.csv", "/Rekonstruktion/Mack/mack_rot_guyot.csv")

mack_squared_deviation <- apply(mvn_list_mack[[6]], 1, function(param_vec) {
  calculate_squared_deviation(mack, param_vec)
})

makkar2012 <- prepare_data("/Rekonstruktion/Makkar/2012/makkar2012_blau_guyot.csv", "/Rekonstruktion/Makkar/2012/makkar2012_rot_guyot.csv")

makkar2012_squared_deviation <- apply(mvn_list_makkar2012[[6]], 1, function(param_vec) {
  calculate_squared_deviation(makkar2012, param_vec)
})

makkar2020 <- prepare_data("/Rekonstruktion/Makkar/2020/makkar2020_blau_guyot.csv", "/Rekonstruktion/Makkar/2020/makkar2020_rot_guyot.csv")

makkar2020_squared_deviation <- apply(mvn_list_makkar2020[[6]], 1, function(param_vec) {
  calculate_squared_deviation(makkar2020, param_vec)
})


popma <- prepare_data("/Rekonstruktion/Medtronic/popma_blau_guyot.csv", "/Rekonstruktion/Medtronic/popma_rot_guyot.csv")

popma_squared_deviation <- apply(mvn_list_popma[[6]], 1, function(param_vec) {
  calculate_squared_deviation(popma, param_vec)
})


thyregod <- prepare_data("/Rekonstruktion/Thyregod/thyregod_blau_guyot.csv", "/Rekonstruktion/Thyregod/thyregod_rot_guyot.csv")

thyregod_squared_deviation <- apply(mvn_list_thyregod[[6]], 1, function(param_vec) {
  calculate_squared_deviation(thyregod, param_vec)
})
```

Die vorliegenden Code-Chunks bestehen aus den zwei Funktionen, check_deviation() und simulate_until_condition().

Die Funktion check_deviation dient der Überprüfung der Abweichung für eine Menge von geschätzten Parametervektoren, in diesem Fall die generierten Parametervektoren aus der Normalverteilung. Dabei wird für jeden Parametervektor die quadrierte Abweichung mithilfe der Funktion calculate_squared_deviation berechnet. Wenn die quadrierte Abweichung eines Parameters den vorgegebenen Schwellwert überschreitet, wird die Variable all_passed auf FALSE gesetzt. Als Schwellwert wird je nach Studie ein manuell festgelegter Wert festgelegt, z.B. wird Gleason et al. 0.3 als SChwellwert festgelegt. Die Festlegung des Quantils wurde durch visuelle Inspektion mithilfe der create_and_save_plot()-Funktion angepasst. Das Ergebnis der Funktion ist TRUE, wenn für alle Parametervektoren die Abweichung unter dem Schwellenwert bleibt, andernfalls ist es FALSE.

Die Funktion simulate_until_condition nutzt die check_deviation-Funktion. In jedem Schleifendurchlauf werden Daten mithilfe der Funktion simulate_data_mv basierend auf den vorherigen Schätzungen simuliert. Anschließend wird die Bedingung durch den Aufruf von check_deviation überprüft. Wenn die Bedingung erfüllt ist, wird die Schleife unterbrochen, andernfalls werden diejenigen Parametervektoren identifiziert, die die Bedingung nicht erfüllen.

Für die Parametervektoren, die aktualisiert werden müssen, werden neue Werte generiert, indem sie mehrmals aus der multivariaten Normalverteilung gezogen werden. Die Aktualisierung erfolgt solange, bis die Bedingung, dass die quadratische Abweichung zu den Realdaten nicht zu hoch ist, erfüllt ist. Die Funktion gibt schließlich die simulierten Daten zurück, die die gewünschte Bedingung erfüllen.

```{r check, echo=TRUE, warning=FALSE, error=FALSE}
# Funktion zur Überprüfung der relativen Abweichung für alle Parametervektoren
check_deviation <- function(guyot_data, estimated_params, threshold) {
  all_passed <- TRUE
  
  if(is.matrix(estimated_params)){
    end <- nrow(estimated_params)
    
    for (i in 1:end) {
    result <- calculate_squared_deviation(guyot_data, estimated_params[i, ])
      
    if (result["sum_squared_deviation"] > threshold) {
      all_passed <- FALSE
    }
  }
  }
  else{
    end <- 1
    
    for (i in 1:end) {
    result <- calculate_squared_deviation(guyot_data, estimated_params)
    
    if (result["sum_squared_deviation"] > threshold) {
      all_passed <- FALSE
    }
  }
  }
  
  return(all_passed)
}

# Funktion zur wiederholten Simulation bis die Bedingung erfüllt ist
simulate_until_condition <- function(fit_results, guyot_data, n_simulations,
                                     thres) {
    # Daten simulieren
    simulated_data <- simulate_data_mv(fit_results, n_simulations)
    
    # # Geeigneten Schwellwert festlegen
    threshold <- thres
    
    while(!check_deviation(guyot_data, simulated_data[["mv_data_transformed"]],
                          threshold)){
      # Überprüfen, ob die Bedingung erfüllt ist
      passed_condition <- check_deviation(guyot_data,
                                          simulated_data[["mv_data_transformed"]],
                                          threshold)
      
      if (passed_condition) {
        break
      }
      
      # Nur die Parametervektoren ersetzen, die die Bedingung nicht erfüllen
      check <- unlist(lapply(1:(2*n_simulations), function(i) {
        check_deviation(guyot_data, simulated_data[["mv_data_transformed"]][i, ], 
                        threshold)
        }))
      indices_to_replace <- which(!check)
      
      for (index in indices_to_replace) {
        # Neue Parametervektoren generieren
        if(simulated_data[["mv_data_transformed"]][index, 5] == 0){
          
          new_params <- c(mvrnorm(1, mu = simulated_data[["mu_0"]], 
                                Sigma = simulated_data[["Sigma_0"]]))
          new_params <- c(exp(new_params[1:3]), 
                          exp(new_params[4]) / ( 1 + exp(new_params[4])), 0)
        
          while (!check_deviation(guyot_data, new_params, threshold)) {
          # Wenn nicht, erneut generieren
          new_params <- c(mvrnorm(1, mu = simulated_data[["mu_0"]], 
                                Sigma = simulated_data[["Sigma_0"]]))
          new_params <- c(exp(new_params[1:3]), 
                          exp(new_params[4]) / ( 1 + exp(new_params[4])), 0)
        }
        }
        
        else if(simulated_data[["mv_data_transformed"]][index, 5] == 1){
          
          new_params <- c(mvrnorm(1, mu = simulated_data[["mu_1"]], 
                                Sigma = simulated_data[["Sigma_1"]]))
          new_params <- c(exp(new_params[1:3]), 
                          exp(new_params[4]) / ( 1 + exp(new_params[4])), 1)
          
          while (!check_deviation(guyot_data, new_params, threshold)) {
          # Wenn nicht, erneut generieren
          new_params <- c(mvrnorm(1, mu = simulated_data[["mu_1"]], 
                                Sigma = simulated_data[["Sigma_1"]]))
          new_params <- c(exp(new_params[1:3]), 
                          exp(new_params[4]) / ( 1 + exp(new_params[4])), 1)
        }
        }
        # Ersetze die Parametervektoren in der simulierten Datenmatrix
        simulated_data[["mv_data_transformed"]][index, ] <- c(shape = new_params[1],
                                                              scale = new_params[2],
                                                              rate = new_params[3],
                                                              mix = new_params[4],
                                                              arm = new_params[5])
    }
    return(simulated_data)}
    return(simulated_data)
}


# Beispielaufruf
simulated_data <- simulate_until_condition(fit_gleason, gleason, 100, 0.1)
mvn_list_gleason <- simulated_data
list.save(mvn_list_gleason, paste0(mypath, "/Simulation/Gleason/mvn_list_gleason.rds"))
mvn_list_gleason <- list.load(paste0(mypath, "/Simulation/Gleason/mvn_list_gleason.rds"))

simulated_data <- simulate_until_condition(fit_jorgensen, jorgensen, 100, 0.1)
mvn_list_jorgensen <- simulated_data
list.save(mvn_list_jorgensen, paste0(mypath, "/Simulation/Jorgensen/mvn_list_jorgensen.rds"))
mvn_list_jorgensen <- list.load(paste0(mypath, "/Simulation/Jorgensen/mvn_list_jorgensen.rds"))

simulated_data <- simulate_until_condition(fit_leon, leon, 100, 0.05)
mvn_list_leon <- simulated_data
list.save(mvn_list_leon, paste0(mypath, "/Simulation/Leon/mvn_list_leon.rds"))
mvn_list_leon <- list.load(paste0(mypath, "/Simulation/Leon/mvn_list_leon.rds"))

simulated_data <- simulate_until_condition(fit_mack, mack, 100, 0.03)
mvn_list_mack <- simulated_data
list.save(mvn_list_mack, paste0(mypath, "/Simulation/Mack/mvn_list_mack.rds"))
mvn_list_mack <- list.load(paste0(mypath, "/Simulation/Mack/mvn_list_mack.rds"))

simulated_data <- simulate_until_condition(fit_makkar2012, makkar2012, 100, 0.1)
mvn_list_makkar2012 <- simulated_data
list.save(mvn_list_makkar2012, paste0(mypath, "/Simulation/Makkar2012/mvn_list_makkar2012.rds"))
mvn_list_makkar2012 <- list.load(paste0(mypath, "/Simulation/Makkar2012/mvn_list_makkar2012.rds"))

simulated_data <- simulate_until_condition(fit_makkar2020, makkar2020, 100, 0.2)
mvn_list_makkar2020 <- simulated_data
list.save(mvn_list_makkar2020, paste0(mypath, "/Simulation/Makkar2020/mvn_list_makkar2020.rds"))
mvn_list_makkar2020 <- list.load(paste0(mypath, "/Simulation/Makkar2020/mvn_list_makkar2020.rds"))

simulated_data <- simulate_until_condition(fit_popma, popma, 100, 0.004)
mvn_list_popma <- simulated_data
list.save(mvn_list_popma, paste0(mypath, "/Simulation/Popma/mvn_list_popma.rds"))
mvn_list_popma <- list.load(paste0(mypath, "/Simulation/Popma/mvn_list_popma.rds"))

simulated_data <- simulate_until_condition(fit_thyregod, thyregod, 100, 0.05)
mvn_list_thyregod <- simulated_data
list.save(mvn_list_thyregod, paste0(mypath, "/Simulation/Thyregod/mvn_list_thyregod.rds"))
mvn_list_thyregod <- list.load(paste0(mypath, "/Simulation/Thyregod/mvn_list_thyregod.rds"))

mvn_list_all <- list.load(paste0(mypath, "/Simulation/all/mvn_list_all.rds"))
```

```{r power_data, echo=TRUE, warning=FALSE, error=FALSE}
create_nv_df <- function(mvn_list, n_sim = 100, n_parameter = 100, tau){
  sim_data_transformed <- mvn_list[["mv_data_transformed"]]
  
  arm_0 <- unname(sim_data_transformed[1:n_parameter, ])
  arm_1 <- unname(sim_data_transformed[(n_parameter+1):(2*n_parameter), ])
  
  generate_data <- lapply(1:n_parameter, function(i) {
    param <- c(mix1 = arm_0[i, 4], shape1 = arm_0[i, 1], 
               scale1 = arm_0[i, 2], rate1 = arm_0[i, 3],
               mix2 = arm_1[i, 4], shape2 = arm_1[i, 1], 
               scale2 = arm_1[i, 2], rate2 = arm_1[i, 3])
    
    data <- replicate(n_sim, generate_mixture_data(n_c = 500, n_e = 500, param, 
                                                  cens_rate = 0.05, tau), 
                      simplify = FALSE)
    
    return(list(data = data, param = param))
  })
  return(generate_data)
}

gleason_create_nv_df <- create_nv_df(mvn_list = mvn_list_gleason, tau = gleason_tau)
gleason_sim_df <- lapply(gleason_create_nv_df, function(result) result$data)
list.save(gleason_sim_df, paste0(mypath, "/Simulation/Gleason/gleason_sim_df.rds"))
gleason_sim_params <- lapply(gleason_create_nv_df, function(result) result$param)

jorgensen_create_nv_df <- create_nv_df(mvn_list = mvn_list_jorgensen, tau = jorgensen_tau)
jorgensen_sim_df <- lapply(jorgensen_create_nv_df, function(result) result$data)
list.save(jorgensen_sim_df, paste0(mypath, "/Simulation/Jorgensen/jorgensen_sim_df.rds"))
jorgensen_sim_params <- lapply(jorgensen_create_nv_df, function(result) result$param)

leon_create_nv_df <- create_nv_df(mvn_list = mvn_list_leon, tau = leon_tau)
leon_sim_df <- lapply(leon_create_nv_df, function(result) result$data)
list.save(leon_sim_df, paste0(mypath, "/Simulation/Leon/leon_sim_df.rds"))
leon_sim_params <- lapply(leon_create_nv_df, function(result) result$param)

mack_create_nv_df <- create_nv_df(mvn_list = mvn_list_mack, tau = mack_tau)
mack_sim_df <- lapply(mack_create_nv_df, function(result) result$data)
list.save(mack_sim_df, paste0(mypath, "/Simulation/Mack/mack_sim_df.rds"))
mack_sim_params <- lapply(mack_create_nv_df, function(result) result$param)

makkar2012_create_nv_df <- create_nv_df(mvn_list = mvn_list_makkar2012, tau = makkar2012_tau)
makkar2012_sim_df <- lapply(makkar2012_create_nv_df, function(result) result$data)
list.save(makkar2012_sim_df, paste0(mypath, "/Simulation/Makkar2012/makkar2012_sim_df.rds"))
makkar2012_sim_params <- lapply(makkar2012_create_nv_df, function(result) result$param)

makkar2020_create_nv_df <- create_nv_df(mvn_list = mvn_list_makkar2020, tau = makkar2020_tau)
makkar2020_sim_df <- lapply(makkar2020_create_nv_df, function(result) result$data)
list.save(makkar2020_sim_df, paste0(mypath, "/Simulation/makkar2020/makkar2020_sim_df.rds"))
makkar2020_sim_params <- lapply(makkar2020_create_nv_df, function(result) result$param)

popma_create_nv_df <- create_nv_df(mvn_list = mvn_list_popma, tau = popma_tau)
popma_sim_df <- lapply(popma_create_nv_df, function(result) result$data)
list.save(popma_sim_df, paste0(mypath, "/Simulation/Popma/popma_sim_df.rds"))
popma_sim_params <- lapply(popma_create_nv_df, function(result) result$param)

thyregod_create_nv_df <- create_nv_df(mvn_list = mvn_list_thyregod, tau = thyregod_tau)
thyregod_sim_df <- lapply(thyregod_create_nv_df, function(result) result$data)
list.save(thyregod_sim_df, paste0(mypath, "/Simulation/Thyregod/thyregod_sim_df.rds"))
thyregod_sim_params <- lapply(thyregod_create_nv_df, function(result) result$param)

all_create_nv_df <- create_nv_df(mvn_list = mvn_list_all, n_parameter = 200, tau = 60)
all_sim_df <- lapply(all_create_nv_df, function(result) result$data)
list.save(all_sim_df, paste0(mypath, "/Simulation/all/all_sim_df.rds"))
all_sim_params <- lapply(all_create_nv_df, function(result) result$param)
```


```{r power_function, echo=TRUE, warning=FALSE, error=FALSE}
compute_power_and_effects <- function(test = c("log", "rmst", "yp"), sim_data, tau) {
  lapply(1:length(sim_data), function(j) {
    sim_df <- sim_data[[j]]

    p_lr <- numeric(length(sim_df))  # Initialisieren Platzhalter für p_lr
    hr <- numeric(length(sim_df))  # Initialisieren Platzhalter für hr
    p_rmst <- numeric(length(sim_df))  # Initialisieren Platzhalter für p_rmst
    rmst_diff <- numeric(length(sim_df))  # Initialisieren Platzhalter für rmst_diff
    p_yp <- numeric(length(sim_df))  # Initialisieren Platzhalter für p_yp
    short_term_hr <- numeric(length(sim_df))  # Initialisieren Platzhalter für short_term_hr

    results <- lapply(1:length(sim_df), function(i) {
      data <- sim_df[[i]]
      ## Testdurchfuehrung
      if ("log" %in% test) {
        # Log-rank Test
        lr_test <- coxph(Surv(Zeit, Zensierung) ~ arm, data = data)
        p_lr <- 1 - pchisq(lr_test$score, 1)

        # Hazard Ratio 
        hr <- lr_test$coefficients[1]

        return(data.frame(p_lr = p_lr,
                          hr = hr))
      }

      if ("rmst" %in% test) {
        # RMST Test
        rmst_test <- rmst2(time = data$Zeit, status = data$Zensierung,
                           arm = data$arm, tau = NULL)
        p_rmst <- rmst_test$unadjusted.result[1, 4]

        # RMST Differenz
        rmst_diff <- rmst_test$unadjusted.result[1, 1]

        return(data.frame(p_rmst = p_rmst,
                          rmst_diff = rmst_diff))
      }

      if ("yp" %in% test) {
        # Daten fuer YP-Test anpassen
        yp_data <- data
        colnames(yp_data) <- c("V1", "V2", "V3")

        yp_data$V1 <- as.numeric(yp_data$V1)
        yp_data$V2 <- as.integer(yp_data$V2)
        yp_data$V3 <- as.integer(yp_data$V3)

        # Yang-Prentice-Test
        yp_test <- YPmodel(yp_data, repNum = 100)
        p_yp <- unname(yp_test$Adlgrk[[1]])

        # Compute Short-term Hazard Ratio
        short_term_hr <- exp(yp_test$Estimate[[1]])[[1]]

        return(data.frame(p_yp = p_yp,
                          short_term_hr = short_term_hr))
      }
    })

    # Power and Effect Measures
    if ("log" %in% test) {
        power_lr <- mean(sapply(results, function(x) x$p_lr < 0.05))
        effect_lr <- mean(sapply(results, function(x) x$hr))

        return(list(power_lr = power_lr, effect_lr = effect_lr))
    }

    if ("rmst" %in% test) {
      power_rmst <- mean(sapply(results, function(x) x$p_rmst < 0.05))
      effect_rmst <- mean(sapply(results, function(x) x$rmst_diff))

      return(list(power_rmst = power_rmst, effect_rmst = effect_rmst))
    }

    if ("yp" %in% test) {
      power_yp <- mean(sapply(results, function(x) x$p_yp < 0.05))
      effect_yp <- mean(sapply(results, function(x) x$short_term_hr))

      return(list(power_yp = power_yp, effect_yp = effect_yp))
    }
  })
}
```

```{r power_log}
gleason_log <- compute_power_and_effects("log", gleason_sim_df, gleason_tau)
list.save(gleason_log, paste0(mypath, "/Simulation/Gleason/gleason_log.rds"))

jorgensen_log <- compute_power_and_effects("log", jorgensen_sim_df, jorgensen_tau)
list.save(jorgensen_log, paste0(mypath, "/Simulation/Jorgensen/jorgensen_log.rds"))

leon_log <- compute_power_and_effects("log", leon_sim_df, leon_tau)
list.save(leon_log, paste0(mypath, "/Simulation/Leon/leon_log.rds"))

mack_log <- compute_power_and_effects("log", mack_sim_df, mack_tau)
list.save(mack_log, paste0(mypath, "/Simulation/Mack/mack_log.rds"))

makkar2012_log <- compute_power_and_effects("log", makkar2012_sim_df, makkar2012_tau)
list.save(makkar2012_log, paste0(mypath, "/Simulation/Makkar2012/makkar2012_log.rds"))

makkar2020_log <- compute_power_and_effects("log", makkar2020_sim_df, makkar2020_tau)
list.save(makkar2020_log, paste0(mypath, "/Simulation/Makkar2020/makkar2020_log.rds"))

popma_log <- compute_power_and_effects("log", popma_sim_df, popma_tau)
list.save(popma_log, paste0(mypath, "/Simulation/Popma/popma_log.rds"))

thyregod_log <- compute_power_and_effects("log", thyregod_sim_df, thyregod_tau)
list.save(thyregod_log, paste0(mypath, "/Simulation/Thyregod/thyregod_log.rds"))

all_log <- compute_power_and_effects("log", all_sim_df, 60)
list.save(all_log, paste0(mypath, "/Simulation/all/all_log.rds"))
```

```{r power_rmst}
gleason_rmst <- compute_power_and_effects("rmst", gleason_sim_df, gleason_tau)
list.save(gleason_rmst, paste0(mypath, "/Simulation/Gleason/gleason_rmst.rds"))

jorgensen_rmst <- compute_power_and_effects("rmst", jorgensen_sim_df, jorgensen_tau)
list.save(jorgensen_rmst, paste0(mypath, "/Simulation/Jorgensen/jorgensen_rmst.rds"))

leon_rmst <- compute_power_and_effects("rmst", leon_sim_df, leon_tau)
list.save(leon_rmst, paste0(mypath, "/Simulation/Leon/leon_rmst.rds"))

mack_rmst <- compute_power_and_effects("rmst", mack_sim_df, mack_tau)
list.save(mack_rmst, paste0(mypath, "/Simulation/Mack/mack_rmst.rds"))

makkar2012_rmst <- compute_power_and_effects("rmst", makkar2012_sim_df, makkar2012_tau)
list.save(makkar2012_rmst, paste0(mypath, "/Simulation/Makkar2012/makkar2012_rmst.rds"))

makkar2020_rmst <- compute_power_and_effects("rmst", makkar2020_sim_df, makkar2020_tau)
list.save(makkar2020_rmst, paste0(mypath, "/Simulation/Makkar2020/makkar2020_rmst.rds"))

popma_rmst <- compute_power_and_effects("rmst", popma_sim_df, popma_tau)
list.save(popma_rmst, paste0(mypath, "/Simulation/Popma/popma_rmst.rds"))

thyregod_rmst <- compute_power_and_effects("rmst", thyregod_sim_df, thyregod_tau)
list.save(thyregod_rmst, paste0(mypath, "/Simulation/Thyregod/thyregod_rmst.rds"))

all_rmst <- compute_power_and_effects("rmst", all_sim_df, 60)
list.save(all_rmst, paste0(mypath, "/Simulation/all/all_rmst.rds"))
```

```{r power_yp}
gleason_yp <- compute_power_and_effects("yp", gleason_sim_df, gleason_tau)
list.save(gleason_yp, paste0(mypath, "/Simulation/Gleason/gleason_yp.rds"))

jorgensen_yp <- compute_power_and_effects("yp", jorgensen_sim_df, jorgensen_tau)
list.save(jorgensen_yp, paste0(mypath, "/Simulation/Jorgensen/jorgensen_yp.rds"))

leon_yp <- compute_power_and_effects("yp", leon_sim_df, leon_tau)
list.save(leon_yp, paste0(mypath, "/Simulation/Leon/leon_yp.rds"))

mack_yp <- compute_power_and_effects("yp", mack_sim_df, mack_tau)
list.save(mack_yp, paste0(mypath, "/Simulation/Mack/mack_yp.rds"))

makkar2012_yp <- compute_power_and_effects("yp", makkar2012_sim_df, makkar2012_tau)
list.save(makkar2012_yp, paste0(mypath, "/Simulation/Makkar2012/makkar2012_yp.rds"))

makkar2020_yp <- compute_power_and_effects("yp", makkar2020_sim_df, makkar2020_tau)
list.save(makkar2020_yp, paste0(mypath, "/Simulation/Makkar2020/makkar2020_yp.rds"))

popma_yp <- compute_power_and_effects("yp", popma_sim_df, popma_tau)
list.save(popma_yp, paste0(mypath, "/Simulation/Popma/popma_yp.rds"))

thyregod_yp <- compute_power_and_effects("yp", thyregod_sim_df, thyregod_tau)
list.save(thyregod_yp, paste0(mypath, "/Simulation/Thyregod/thyregod_yp.rds"))

all_yp <- compute_power_and_effects("yp", all_sim_df, 60)
list.save(all_yp, paste0(mypath, "/Simulation/all/all_yp.rds"))
```



